# 💬 Linux Chat
### 📌 소개
> **💬 TCP/IP 기반의 소켓 통신을 사용하는 리눅스 epoll 기반의 비동기 멀티스레드 채팅 서버입니다.**

- epoll 메커니즘이 해당 이벤트를 처리할 준비가 된 소켓을 식별합니다. 준비된 소켓의 이벤트는 스레드풀로 전달되어 처리됩니다. 
- 스레드풀은 여러 개의 스레드를 포함하고 있으며, 각 스레드는 독립적으로 클라이언트의 요청을 처리합니다.

### 📌 실행 영상
- https://youtu.be/xaTnuzsmIqI

### 📌 실행 방법
1. 컴파일하기
```
g++ -o server server.cpp -lpthread -std=c++11

g++ -o client client.cpp -lpthread -std=c++11
```

2. 실행하기 (서버가 실행된 상태에서 클라이언트가 입장해야 합니다)
```
./server

./client
```
### 📌 개발 환경
- C++, CentOS 7, VMware, Visual Studio Code
### 📌 구현 기능
- 클라이언트는 서버에 연결하여 실시간으로 메시지를 주고받을 수 있습니다.
- 서버는 스레드 풀을 사용하여 각 클라이언트의 요청을 병렬로 처리합니다.
- 채팅 기능
  - 입장 시 이름 작성 (중복 체크)
  - 메시지 송수신 시각
  - 전체 메시지 
  - 귓속말 메시지 (명령어 : /whisper ’귓속말 상대’ ‘대화내용’)
  - 채팅방에 있는 전원 이름 조회 (명령어 : /list)
  - 이름 바꾸기 (명령어 : /name ‘바꾸고 싶은 이름‘)

### 📌 서버 코드에서의 스레드풀 사용 방식

- 서버 초기화 시 `ThreadPool` 객체를 생성하고, 이때 스레드풀의 크기를 지정합니다. 이 크기는 서버가 동시에 처리할 수 있는 최대 요청 수를 결정합니다.
- 서버의 메인 루프에서 `epoll_wait` 를 사용하여 이벤트를 대기합니다.
- 이벤트가 발생하면, 연결 요청 처리(`accept_connections`) 또는 클라이언트 요청 처리(`handle_client`) 작업을 스레드풀의 큐(`tasks`)에 추가합니다.
- 각 요청은 작업 큐에 추가되고, 사용 가능한 스레드에 의해 순차적으로 처리됩니다. 스레드풀에서 대기 중인 스레드가 이 작업을 가져가 처리합니다. 
- 처리가 완료되면 스레드는 다음 작업을 위해 다시 대기 상태로 돌아갑니다.

### 📌 고민한 점
> **💬 스레드를 어떻게 할당할까?**

처음에 설계할 때에는, 하나의 클라이언트가 접속하면 담당 스레드를 주어서, 스레드 풀 관리자에 의해 스레드 풀에서 한개의 스레드가 할당되어 클라이언트가 접속을 종료할 때까지 그 스레드는 그 클라이언트만 담당하도록 했습니다. 이 방식의 단점은 만약 해당 클라이언트의 입력이 오랫동안 없더라도 해당 스레드는 클라이언트로부터 언제 입력이 들어올지 모르기 때문에 다른 곳에 사용될 수 없다는 점이었습니다. 

그래서 하나의 스레드는 하나의 요청작업(=패킷)에 할당이 되고 해당 요청을 처리하면 다시 스레드 풀에 반환되도록 설계해보았습니다. 이 방식을 사용한다면 생성된 스레드 수와 접속하는 클라이언트 수는 서로 독립이기 때문에, 무한의 클라이언트가 접속할 수 있습니다. 

아래는 개발한 시스템의 서버의 설계 다이어그램과 3개의 클라이언트의 접속 화면입니다. 클라이언트는 거의 무한에 가깝게 접속할 수 있다는 장점이 있습니다.(물론 실제로는 서버 능력에 따라 달라질 것이며, 50개의 클라이언트까지 접속 후 채팅이 가능한 것을 확인했습니다.) 

### 📌 설계 다이어그램

### 📌 실행 캡쳐 화면
<img width="1057" alt="스크린샷 2024-01-27 오후 3 13 55" src="https://github.com/strurao/LinuxChat/assets/126440235/be751a52-f14d-4d0f-ba9e-5d4f2804f078">
